<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="从编译器角度出发探索如何在go中实现AOP"><meta name="keywords" content="编译原理,Golang"><meta name="author" content="也许拜了个拜"><meta name="copyright" content="也许拜了个拜"><title>从编译器角度出发探索如何在go中实现AOP | maybeByeのspace</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%88AST%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">语法分析过程（AST阶段）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8CAST%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">类型检查和AST转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0aop"><span class="toc-number">3.</span> <span class="toc-text">如何实现aop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-World"><span class="toc-number">4.</span> <span class="toc-text">Hello World</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">也许拜了个拜</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="">Follow</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/banner.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">maybeByeのspace</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">从编译器角度出发探索如何在go中实现AOP</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">技术总结</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><strong>起源</strong>：在当下微服务盛行，服务的依赖越来越复杂，服务的颗粒越来越细，业务迭代越来越频繁，软件的系统性测试的维护成本越来越高，对于特别复杂的业务场景的单测编写或者接口测试的数据构造是越发困难。所以我们项目小组开发了智能单测辅助工具来解决这些问题。<br> <br/><br> <br/><br> <br/></p>
<p><strong>需求</strong>：针对单测而言，工具需要做的就是在测试环境或者线上环境录制真实的数据，在线下进行解析，构造单元测试生成高质量且真实的case，在提高了系统的稳定性，也同时降低了编写单测的成本，用真实数据构成的测试用例辅助开发进行构造高质量的单测cases。技术实现的关键点就在如何录制线上流量以及线下解析录制文件和代码生成这三步，而对于录制线上流量就会涉及到类似Java的字节码增强的技术，所以我们今天就来先看看ugo录制模块是怎么实现录制流量的底层原理。</p>
 <br/>
 <br/>
 <br/>

<p><img src="/images/pasted-1.png"></p>
 <br/>
 <br/>
 <br/>
对复杂的且不允许有代码侵入的开发场景，大家可能大家首先想到的是Java的spring里面的AOP，的确作为非常成熟的语言，java想做增强字节码其实方式是非常多且成熟的，常用的静态代理、JavaProxy动态代理、用ASM库动态修改子类的CGLIB，如果想对没有加载到JVM的目标类做字节码增强可以用JavaAssist、修改已加载类的类库的instrument接口等。总之就是实现起来很成熟。所以golang有没有类似的字节码增强技术呢，因为go没有字节码所以遗憾的是暂时没有这种技术支持。


<p>但是，golang实现了自举，（自举 Bootstrapping，“用要编译的目标编程语言编写其编译器（或汇编器）”），自举支持使用更为高级、提供更多高级抽象的语言来编写编译器，意味着我们可以直接修改go的编译器来实现类似字节码增强来实现aop的功能。<br> <br/><br> <br/><br> <br/></p>
<p>首先要了解go的编译器：</p>
<blockquote>
<p><strong>编译器</strong>的作用就是把人写的代码转成机器码，所有的编译器都是由前端和后端构成，编译器的前端一般承担着词法分析、语法分析、类型检查和中间代码生成几部分工作，而编译器后端主要负责目标代码的生成和优化。<br><strong>编译过程</strong>：go文件  -&gt;  AST  -&gt;  SSA (Static Single Assignment)  -&gt;  machine-specific SSA  -&gt;  Machine</p>
</blockquote>
<p>代码解释的关键阶段是语法分析阶段，先让一起来看看go的ast构造过程</p>
<h2 id="语法分析过程（AST阶段）"><a href="#语法分析过程（AST阶段）" class="headerlink" title="语法分析过程（AST阶段）"></a>语法分析过程（AST阶段）</h2><p>Go 语言的解析器使用了  <a target="_blank" rel="noopener" href="http://https//en.wikipedia.org/wiki/LALR_parser">LALR</a> 的文法来解析词法分析过程中输出的 Token 序列，最右推导加向前查看构成了 Go 语言解析</p>
<p>器的最基本原理，也是大多数编程语言的选择。</p>
<p>Go源码主要会用源码路径下的<strong>cmd/compile/internal/gc.parseFiles</strong>函数进行ast解析</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parseFiles concurrently parses files into *syntax.File structures.</span></span><br><span class="line"><span class="comment">// Each declaration in every *syntax.File is converted to a syntax tree</span></span><br><span class="line"><span class="comment">// and its root represented by *Node is appended to xtop.</span></span><br><span class="line"><span class="comment">// Returns the total count of parsed lines.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFiles</span><span class="params">(filenames []<span class="keyword">string</span>)</span> <span class="title">uint</span></span> &#123;...&#125;</span><br><span class="line">如注释所说这里会用多个goroutine来解析文件，最终这个parseFiles函数会将整个文件对应的语法树存到src/compile/internal/gc/noder.<span class="keyword">go</span>中的noder结构体中，一个 noder 对象相当于 AST 语法树中的节点，构成了整个语法树。noder 结构体定义如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// noder transforms package syntax&#x27;s AST into a Node tree.</span></span><br><span class="line"><span class="keyword">type</span> noder <span class="keyword">struct</span> &#123;</span><br><span class="line">    basemap   <span class="keyword">map</span>[*syntax.PosBase]*src.PosBase</span><br><span class="line">    basecache <span class="keyword">struct</span> &#123;</span><br><span class="line">        last *syntax.PosBase</span><br><span class="line">        base *src.PosBase</span><br><span class="line">    &#125;</span><br><span class="line">    file       *syntax.File</span><br><span class="line">    filename   <span class="keyword">string</span></span><br><span class="line">    linknames  []linkname</span><br><span class="line">    pragcgobuf [][]<span class="keyword">string</span></span><br><span class="line">    err        <span class="keyword">chan</span> syntax.Error</span><br><span class="line">    scope      ScopeID</span><br><span class="line">    <span class="comment">// scopeVars is a stack tracking the number of variables declared in the</span></span><br><span class="line">    <span class="comment">// current function at the moment each open scope was opened.</span></span><br><span class="line">    scopeVars []<span class="keyword">int</span></span><br><span class="line">    lastCloseScopePos syntax.Pos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最关键的字段就是***syntax.File **</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    Pragma   Pragma </span><br><span class="line">    PkgName  *Name</span><br><span class="line">    DeclList []Decl</span><br><span class="line">    Lines    <span class="keyword">uint</span></span><br><span class="line">    node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Pragma : 是词法分析的结果，其中，此法分析的函数主要是 ：type PragmaHandler func(pos Pos, blank bool, text string, current Pragma) Pragma</p>
</blockquote>
<blockquote>
<p>PkgName : 就是编译的 package 的名称</p>
</blockquote>
<blockquote>
<p>DeclList []Decl : DeclList 是需要编译的每一行代码的 Token 值。Decl 是一个继承了 Node 接口的接口。</p>
</blockquote>
<blockquote>
<p>Lines : 表示一共有多少行代码需要编译<br>node : 是一个 Node Tree 的节点，这个 node 结构体中只有在源代码中的位置属性，并且实现了 Node 接口。<br>语法和词法解析都会围绕*syntax.File  进行所以我们先来看看词法和语法解析所需的依赖结构体</p>
</blockquote>
<p>go的语法解析器用到了parser 、词法解析器用到了scanner </p>
<p>先来看看cmd/compile/internal/syntax.Parse </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> parser <span class="keyword">struct</span> &#123;</span><br><span class="line">    file  *PosBase</span><br><span class="line">    errh  ErrorHandler</span><br><span class="line">    mode  Mode</span><br><span class="line">    pragh PragmaHandler</span><br><span class="line">    scanner</span><br><span class="line"></span><br><span class="line">    base   *PosBase <span class="comment">// current position base</span></span><br><span class="line">    first  error    <span class="comment">// first error encountered</span></span><br><span class="line">    errcnt <span class="keyword">int</span>      <span class="comment">// number of errors encountered</span></span><br><span class="line">    pragma Pragma   <span class="comment">// pragmas</span></span><br><span class="line"></span><br><span class="line">    fnest  <span class="keyword">int</span>    <span class="comment">// function nesting level (for error handling)</span></span><br><span class="line">    xnest  <span class="keyword">int</span>    <span class="comment">// expression nesting level (for complit ambiguity resolution)</span></span><br><span class="line">    indent []<span class="keyword">byte</span> <span class="comment">// tracing support</span></span><br><span class="line"></span><br><span class="line">    imports <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// contents of imports</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是解析器的结构体声明会用到相关的变量，可以看到词语解析器scanner是组合到了parser中</p>
<p>scanner 位于src\cmd\compile\internal\syntax\scanner.go 中</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> scanner <span class="keyword">struct</span> &#123;</span><br><span class="line">    source</span><br><span class="line">    mode   <span class="keyword">uint</span></span><br><span class="line">    nlsemi <span class="keyword">bool</span> <span class="comment">// if set &#x27;\n&#x27; and EOF translate to &#x27;;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// current token, valid after calling next()</span></span><br><span class="line">    line, col <span class="keyword">uint</span></span><br><span class="line">    blank     <span class="keyword">bool</span> <span class="comment">// line is blank up to col</span></span><br><span class="line">    tok       token</span><br><span class="line">    lit       <span class="keyword">string</span>   <span class="comment">// valid if tok is _Name, _Literal, or _Semi (&quot;semicolon&quot;, &quot;newline&quot;, or &quot;EOF&quot;); may be malformed if bad is true</span></span><br><span class="line">    bad       <span class="keyword">bool</span>     <span class="comment">// valid if tok is _Literal, true if a syntax error occurred, lit may be malformed</span></span><br><span class="line">    kind      LitKind  <span class="comment">// valid if tok is _Literal</span></span><br><span class="line">    op        Operator <span class="comment">// valid if tok is _Operator, _AssignOp, or _IncOp</span></span><br><span class="line">    prec      <span class="keyword">int</span>      <span class="comment">// valid if tok is _Operator, _AssignOp, or _IncOp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 接下来就是具体怎么解析的过程了：</p>
<p>go会在主程序入口文件中调用gc.Main函数，也就是go build的主要构建过程，gc.Main中会调用</p>
<p>cmd/compile/internal/gc.parseFiles方法来实现词法分析和语法分析。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main parses flags and Go source files specified in the command-line</span></span><br><span class="line"><span class="comment">// arguments, type-checks the parsed Go package, compiles functions to machine</span></span><br><span class="line"><span class="comment">// code, and finally writes the compiled package definition to disk.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">(archInit <span class="keyword">func</span>(*Arch)</span>)</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     lines := parseFiles(flag.Args())</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** parseFiles的主要工作流程是**：</p>
<ul>
<li>创建所有文件的noder列表，每个文件保存为一个noder</li>
</ul>
<ul>
<li>遍历所有文件,其中包括以下几个操作</li>
</ul>
<blockquote>
<p> <strong>每个文件对应生成一个noder，添加到noder列表</strong></p>
</blockquote>
<blockquote>
<p><strong>开一个Goroutine来解析源文件，将解析的结果保存到noder结构体中的file结构中，其实解析的函数就是syntax.Parse() 最主要的函数就是syntax.parser.fileOrNil（fileOrNil很关键，按下不表）</strong></p>
</blockquote>
<blockquote>
<p><strong>遍历结束后，将该 Node 节点加入到 xtop tree 中，也就是 AST 抽象语法树</strong></p>
</blockquote>
<blockquote>
<p><strong>生成 Node Tree 树的过程在  <strong>p.node()</strong>  函数中，就是将 noder 结构体转换成 Node 节点类型，添加到 xtop tree 中，xtop 就是这颗语法树，供后面类型检查使用。</strong></p>
</blockquote>
<p>具体代码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFiles</span><span class="params">(filenames []<span class="keyword">string</span>)</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">    <span class="comment">//  创建 noder 列表</span></span><br><span class="line">    noders := <span class="built_in">make</span>([]*noder, <span class="number">0</span>, <span class="built_in">len</span>(filenames))</span><br><span class="line">    <span class="comment">// 表示最多能同时开启多少个文件描述符</span></span><br><span class="line">    sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, runtime.GOMAXPROCS(<span class="number">0</span>)+<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  遍历 所有文件</span></span><br><span class="line">    <span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        <span class="comment">//  创建 noder 对现象，并且添加到 noder 列表中</span></span><br><span class="line">        p := &amp;noder&#123;</span><br><span class="line">            basemap: <span class="built_in">make</span>(<span class="keyword">map</span>[*syntax.PosBase]*src.PosBase),</span><br><span class="line">            err:     <span class="built_in">make</span>(<span class="keyword">chan</span> syntax.Error),</span><br><span class="line">        &#125;</span><br><span class="line">        noders = <span class="built_in">append</span>(noders, p)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  每个文件用一个 Goroutine 去解析</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(filename <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem &#125;()</span><br><span class="line">            <span class="keyword">defer</span> <span class="built_in">close</span>(p.err)</span><br><span class="line">            base := syntax.NewFileBase(filename)</span><br><span class="line"></span><br><span class="line">            f, err := os.Open(filename)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                p.error(syntax.Error&#123;Msg: err.Error()&#125;)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">            <span class="comment">//   文件解析的主要过程</span></span><br><span class="line">            p.file, _ = syntax.Parse(base, f, p.error, p.pragma, syntax.CheckBranches) <span class="comment">// errors are tracked via p.error</span></span><br><span class="line">        &#125;(filename)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面代码段主要是将 noder 列表中的节点，添加到 xTop 中。</span></span><br><span class="line">    <span class="keyword">var</span> lines <span class="keyword">uint</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> noders &#123;</span><br><span class="line">        <span class="keyword">for</span> e := <span class="keyword">range</span> p.err &#123;</span><br><span class="line">            p.yyerrorpos(e.Pos, <span class="string">&quot;%s&quot;</span>, e.Msg)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  node() 方法将 noders 转成 Node 节点，添加到 xtop 这棵树中</span></span><br><span class="line">        p.node()</span><br><span class="line">        lines += p.file.Lines</span><br><span class="line">        p.file = <span class="literal">nil</span> <span class="comment">// release memory</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nsyntaxerrors != <span class="number">0</span> &#123;</span><br><span class="line">            errorexit()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always run testdclstack here, even when debug_dclstack is not set, as a sanity measure.</span></span><br><span class="line">        testdclstack()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    localpkg.Height = myheight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析的过程中调用了syntax.Parse()函数，该函数位于src\cmd\compile\internal\syntax\syntax.go 文件，就是词法解析的过程<br>该函数初始化了一个新的cmd/compile/internal/syntax.parser结构构体，就是本文上面一部分说的语法解析器，并且该函数通过<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/syntax.parser.fileOrNil"><code>cmd/compile/internal/syntax.parser.fileOrNil</code></a> 方法开启了对当前文件的词法和语法解析</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(base *PosBase, src io.Reader, errh ErrorHandler, pragh PragmaHandler, mode Mode)</span> <span class="params">(_ *File, first error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p parser</span><br><span class="line">p.init(base, src, errh, pragh, mode)</span><br><span class="line">p.next()（词法分析）</span><br><span class="line"><span class="keyword">return</span> p.fileOrNil(), p.first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>词法分析器其实是在p.next()中调用的。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the scanner mode includes the directives (but not the comments)</span></span><br><span class="line"><span class="comment">// flag, only comments containing a //line, /*line, or //go: directive</span></span><br><span class="line"><span class="comment">// are reported, in the same way as regular comments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scanner)</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">   nlsemi := s.nlsemi</span><br><span class="line">   s.nlsemi = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>可以看到next()方法的接收器是scanner, 在go中因为词法分析器嵌套到了语法分析器中，所以词法分析和语法分析是一起进行的。p.next()调用的实际山scanner的next方法，它会直接回去文件中的下一个Token。</p>
<p>​        </p>
<p> src/cmd/compile/internal/syntax/nodes.go 文件中也定义了其他节点的结构体，其中包含了全部声明类型的</p>
<p>函数声明的结构：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">    Decl <span class="keyword">interface</span> &#123;</span><br><span class="line">        Node</span><br><span class="line">        aDecl()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FuncDecl <span class="keyword">struct</span> &#123;</span><br><span class="line">        Attr   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">        Recv   *Field</span><br><span class="line">        Name   *Name</span><br><span class="line">        Type   *FuncType</span><br><span class="line">        Body   *BlockStmt</span><br><span class="line">        Pragma Pragma</span><br><span class="line">        decl</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 函数主体*BlockStmt其实是一个cmd/compile/internal/syntax.Stmt数组</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BlockStmt <span class="keyword">struct</span> &#123;</span><br><span class="line">    List   []Stmt</span><br><span class="line">    Rbrace Pos</span><br><span class="line">    stmt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** syntax.Stmt<strong>是一个接口，实现该接口的类型也非常多，在go 15版本中有18不同的实现<br><img src="https://km.woa.com/gkm/api/img/cos-file-url?url=https://km-pro-1258638997.cos.ap-guangzhou.myqcloud.com/files/photos/pictures/202110/1635501312-9933-617bc500f2859-265283.png&is_redirect=1" alt="enter image description here"><br>这些类型其实和</strong>go/ast**下的类型大概率都是对应的，但是还有一定区别（大佬感兴趣可以研究研究<br><img src="https://km.woa.com/gkm/api/img/cos-file-url?url=https://km-pro-1258638997.cos.ap-guangzhou.myqcloud.com/files/photos/pictures/202110/1635501503-9713-617bc5bfed298-188577.png&is_redirect=1" alt="enter image description here"></p>
<p>这些不同类型的cmd/compile/internal/syntax.Stmt构成了全部命令式的Go语言代码，从中我们可以看到很多熟悉的控制结构，例如if、for 、switch、select，这些命令式的结构在其他的编程语言中也非常常见。</p>
<p>通过词法解析和语法解析，go会把源文件转换为上面定义的file的树型结构。里面包含了各种各样的stmt,至此结束了ast树的转化。</p>
<h2 id="类型检查和AST转换"><a href="#类型检查和AST转换" class="headerlink" title="类型检查和AST转换"></a>类型检查和AST转换</h2><p>解析完之后就是类型检查和AST转换了，简单讲就是会对构建好的ast树进行遍历，在每个节点上都会对当前子树的类型进行验证，所有的类型错误和不匹配都会在这个阶段被暴露出来，其中包括：结构体对接口的实现。实现aop的功能对这一类型检查过程其实不主要涉及，在此就不再展开，感兴趣可以参考 /<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck//">https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck//</a></p>
<h2 id="如何实现aop"><a href="#如何实现aop" class="headerlink" title="如何实现aop"></a>如何实现aop</h2><p>在上面主要介绍了go编译器词法分析和语法分析之后，实现aop的方案是显而易见的，我们可以在<br><strong>cmd/compile/internal/gc.parseFiles</strong>函数构建ast的时候，对已经构造好的ast树进行修改，因为go已经有通过实现接口** syntax.Stmt**的十几种结构体，所以可以将自己想要植入的代码用对应的结构体构造出来，来实现代码插入的效果。</p>
<p>这也是我们在UGO智能单测辅助工具运用到的核心技术之一，我们需要在接口调用的时候记录整个函数调用的链路，同时录制函数的入参、返回值、调用函数的线程id等相对应的信息，这时候就要在函数的编译构建的时候将记录入参、返回值等信息的切面代码通过改写ast的构建织入业务的代码中，只要构建成功之后就可以将录制的流量输出到我们的存储介质中给解析模块用。改写ast需要改写、定制化go源码，业务代码并不需要改动，真正意义上实现了无侵入aop，只需要配置一个定制版的go即可。</p>
<p>下面通过一个简单的小例子来看看go 的编译增强的具体实现</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>我们实现在执行ugo()函数的前打印”start UGO …” 后打印 “end UGO …”。</p>
<ul>
<li>先去github上下载一份go的源代码到本地，然后切换分支选择合适的版本，我这里选用的是go 15版本，这个go是我们修改ast的go，下文叫做定制版go</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/golang/go.git</span><br><span class="line">cd $HOME/src/github.com/golang/go</span><br><span class="line">git checkout release-branch.go1.15</span><br></pre></td></tr></table></figure>

<ul>
<li>然后装一个编译源码用的Bootstrap环境 go是自举的语言go编译器通过go语言编译<br>一般bootstrap的go版本&gt;=编译的go版本就行，本地再下载一个go就可以，确保版本大于定制版的go<br>这样定制版的go才能用它。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir $HOME/go_boostrap</span><br><span class="line">cd $HOME/go_bootstrap</span><br><span class="line">curl https://dl.google.com/go/go1.15.12.darwin-amd64.tar.gz | tar xvzf -</span><br><span class="line">mv go go_bootstrap_15</span><br></pre></td></tr></table></figure>

<ul>
<li>回到定制版的go目录，export bootstrap环境</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/src/github.com/golang/go/src</span><br><span class="line">echo &#x27;export GOROOT_BOOTSTRAP=$HOME/go_bootstrap/go1.15.12&#x27; &gt;&gt; .envrc</span><br></pre></td></tr></table></figure>

<ul>
<li>先尝试编译定制版的go</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/src/github.com/golang/go/src</span><br><span class="line">./make.bash</span><br></pre></td></tr></table></figure>

<p>这一步骤编译会很慢，如果环境正常会有类似以下输出，就代表可以进行下一步操作了<br><img src="https://km.woa.com/gkm/api/img/cos-file-url?url=https://km-pro-1258638997.cos.ap-guangzhou.myqcloud.com/files/photos/pictures/202110/1635507538-2081-617bdd5232d62-820980.png&is_redirect=1" alt="enter image description here"></p>
<ul>
<li>在本地创建一个测试项目也就是执行ugo()函数的库，goroot选择刚才编译好的定制版的go的路径<br>直接在本地ide新建一个项目，然后在终端里面：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT=$HOME/src/github.com/golang/go   # 定制版Go的路径</span><br><span class="line">export PATH=$GOROOT/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>创建main</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">UGO</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">     fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello(context.Background())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保你本地的测试项目是由定制版的go完成编译的。</p>
<ul>
<li>现在准备好了环境要做的就是更改go源码了，直接找到cmd/compile/internal/gc/noder.go这个文件，找到第52行的</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">   p.file, _ = syntax.Parse(base, f, p.error, p.pragma, syntax.CheckBranches) <span class="comment">// errors are tracked via p.error</span></span><br><span class="line">&#125;(filename)</span><br></pre></td></tr></table></figure>

<p>加入下面的代码，修改p.file的值：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">p.file, _ = syntax.Parse(base, f, p.error, p.pragma, syntax.CheckBranches) <span class="comment">// errors are tracked via p.error</span></span><br><span class="line">            <span class="keyword">if</span> p.file.PkgName.Value == <span class="string">&quot;main&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> _, d := <span class="keyword">range</span> p.file.DeclList &#123;</span><br><span class="line">                    d, _ := d.(*syntax.FuncDecl)</span><br><span class="line">                    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> !strings.HasPrefix(d.Name.Value, <span class="string">&quot;UGO&quot;</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    d.Body.List = <span class="built_in">append</span>([]syntax.Stmt&#123;</span><br><span class="line">                        &amp;syntax.ExprStmt&#123;</span><br><span class="line">                            X: &amp;syntax.CallExpr&#123;</span><br><span class="line">                                Fun: &amp;syntax.SelectorExpr&#123;</span><br><span class="line">                                    X:   &amp;syntax.Name&#123;Value: <span class="string">&quot;fmt&quot;</span>&#125;,</span><br><span class="line">                                    Sel: &amp;syntax.Name&#123;Value: <span class="string">&quot;Println&quot;</span>&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                ArgList: []syntax.Expr&#123;</span><br><span class="line">                                    &amp;syntax.BasicLit&#123;</span><br><span class="line">                                        Value: strconv.Quote(<span class="string">&quot;start &quot;</span> + d.Name.Value + <span class="string">&quot;...&quot;</span>),</span><br><span class="line">                                        Kind:  syntax.StringLit,</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &amp;syntax.CallStmt&#123;</span><br><span class="line">                            Tok: syntax.Defer,</span><br><span class="line">                            Call: &amp;syntax.CallExpr&#123;</span><br><span class="line">                                Fun: &amp;syntax.SelectorExpr&#123;</span><br><span class="line">                                    X:   &amp;syntax.Name&#123;Value: <span class="string">&quot;fmt&quot;</span>&#125;,</span><br><span class="line">                                    Sel: &amp;syntax.Name&#123;Value: <span class="string">&quot;Println&quot;</span>&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                ArgList: []syntax.Expr&#123;</span><br><span class="line">                                    &amp;syntax.BasicLit&#123;</span><br><span class="line">                                        Value: strconv.Quote(<span class="string">&quot;end &quot;</span> + d.Name.Value + <span class="string">&quot;...&quot;</span>),</span><br><span class="line">                                        Kind:  syntax.StringLit,</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;, d.Body.List...)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br></pre></td></tr></table></figure>

<p>改完之后重新编译定制版go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/src/github.com/golang/go/src</span><br><span class="line">./make.bash</span><br><span class="line"></span><br><span class="line">cd $HOME/GolangProject/Hello</span><br><span class="line">go clean -cache</span><br><span class="line">go run hello/main.go</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start UGO...</span><br><span class="line">hello world</span><br><span class="line">end UGO...</span><br></pre></td></tr></table></figure>

<p>但是我们如果在源代码中没有引用fmt包，会咋样呢<br>删掉后，重新编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go clean -cache; go run Hello/main.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">helloworld/main.go:7:16: undefined: fmt in fmt.Println </span><br></pre></td></tr></table></figure>

<p>肯定会报错，但是我们在语法树中加上import呢？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p.file.PkgName.Value == <span class="string">&quot;main&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> _, d := <span class="keyword">range</span> p.file.DeclList &#123;</span><br><span class="line">                    d, _ := d.(*syntax.FuncDecl)</span><br><span class="line">                    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> !strings.HasPrefix(d.Name.Value, <span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    hasHello = <span class="literal">true</span></span><br><span class="line">                    d.Body.List = <span class="built_in">append</span>([]syntax.Stmt&#123;</span><br><span class="line">                        &amp;syntax.ExprStmt&#123;</span><br><span class="line">                            X: &amp;syntax.CallExpr&#123;</span><br><span class="line">                                Fun: &amp;syntax.SelectorExpr&#123;</span><br><span class="line">                                    X:   &amp;syntax.Name&#123;Value: <span class="string">&quot;fmt&quot;</span>&#125;,</span><br><span class="line">                                    Sel: &amp;syntax.Name&#123;Value: <span class="string">&quot;Println&quot;</span>&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                ArgList: []syntax.Expr&#123;</span><br><span class="line">                                    &amp;syntax.BasicLit&#123;</span><br><span class="line">                                        Value: strconv.Quote(<span class="string">&quot;start &quot;</span> + d.Name.Value + <span class="string">&quot;...&quot;</span>),</span><br><span class="line">                                        Kind:  syntax.StringLit,</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &amp;syntax.CallStmt&#123;</span><br><span class="line">                            Tok: syntax.Defer,</span><br><span class="line">                            Call: &amp;syntax.CallExpr&#123;</span><br><span class="line">                                Fun: &amp;syntax.SelectorExpr&#123;</span><br><span class="line">                                    X:   &amp;syntax.Name&#123;Value: <span class="string">&quot;fmt&quot;</span>&#125;,</span><br><span class="line">                                    Sel: &amp;syntax.Name&#123;Value: <span class="string">&quot;Println&quot;</span>&#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                ArgList: []syntax.Expr&#123;</span><br><span class="line">                                    &amp;syntax.BasicLit&#123;</span><br><span class="line">                                        Value: strconv.Quote(<span class="string">&quot;end &quot;</span> + d.Name.Value + <span class="string">&quot;...&quot;</span>),</span><br><span class="line">                                        Kind:  syntax.StringLit,</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;, d.Body.List...)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> hasHello &#123;</span><br><span class="line">                hasFmtImport := <span class="literal">false</span></span><br><span class="line">                <span class="keyword">for</span> _, d := <span class="keyword">range</span> p.file.DeclList &#123;</span><br><span class="line">                    d, _ := d.(*syntax.ImportDecl)</span><br><span class="line">                    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> d.Path.Value != <span class="string">&quot;fmt&quot;</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    hasFmtImport = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> !hasFmtImport &#123;</span><br><span class="line">                    p.file.DeclList = <span class="built_in">append</span>([]syntax.Decl&#123;</span><br><span class="line">                        &amp;syntax.ImportDecl&#123;</span><br><span class="line">                            Path: &amp;syntax.BasicLit&#123;</span><br><span class="line">                                Value: <span class="string">`&quot;fmt&quot;`</span>, Kind: syntax.StringLit,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;, p.file.DeclList...)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br></pre></td></tr></table></figure>

<p>重新编译golang，执行go run</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go clean -cache; go run Hello/main.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">Hello/main.go:1:9: can&#x27;t find import: &quot;fmt&quot;</span><br></pre></td></tr></table></figure>

<p>还是会报错，原因是在findpkg的过程中，包变量packageFile是从这个map中获取</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> packageFile != <span class="literal">nil</span> &#123;</span><br><span class="line">        file, ok = packageFile[name]</span><br><span class="line">        <span class="keyword">return</span> file, ok</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<p>packageFile在readImportCfg中初始化</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readImportCfg</span><span class="params">(file <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   packageFile = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">   data, err := ioutil.ReadFile(file)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">&quot;-importcfg: %v&quot;</span>, err)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>入参的string是调用compile命令时给的-importcfg的值<br><img src="https://km.woa.com/gkm/api/img/cos-file-url?url=https://km-pro-1258638997.cos.ap-guangzhou.myqcloud.com/files/photos/pictures/202110/1635509662-1401-617be59e2238c-226036.png&is_redirect=1" alt="enter image description here"><br>文件  <code>cmd/go/internal/work/exec.go</code>  第634行，有关importcfg的内容的逻辑</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare Go import config.</span></span><br><span class="line"><span class="comment">// We start it off with a comment so it can&#x27;t be empty, so icfg.Bytes() below is never nil.</span></span><br><span class="line"><span class="comment">// It should never be empty anyway, but there have been bugs in the past that resulted</span></span><br><span class="line"><span class="comment">// in empty configs, which then unfortunately turn into &quot;no config passed to compiler&quot;,</span></span><br><span class="line"><span class="comment">// and the compiler falls back to looking in pkg itself, which mostly works,</span></span><br><span class="line"><span class="comment">// except when it doesn&#x27;t.</span></span><br><span class="line"><span class="keyword">var</span> icfg bytes.Buffer</span><br><span class="line">fmt.Fprintf(&amp;amp;icfg, <span class="string">&quot;# import config\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, raw := <span class="keyword">range</span> a.Package.Internal.RawImports &#123;</span><br><span class="line">   final := a.Package.Imports[i]</span><br><span class="line">   <span class="keyword">if</span> final != raw &#123;</span><br><span class="line">      fmt.Fprintf(&amp;amp;icfg, <span class="string">&quot;importmap %s=%s\n&quot;</span>, raw, final)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在文件  <code>go/build/build.go=，先用 =go/parser.ParseFile</code>  解析源文件，然后获取其中的imports</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pf, err := parser.ParseFile(fset, filename, data, parser.ImportsOnly|parser.ParseComments)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    badFile(err)</span><br><span class="line">    continue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以修改build.go这个文件，将自己需要的import直接加入，多加的话这里也不会报错因为已经经过了类型检查</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add import</span></span><br><span class="line">hasFmtImport := <span class="literal">false</span></span><br><span class="line">hasEcodingJsonImport := <span class="literal">false</span></span><br><span class="line">hasRuntime := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> pf.Imports &#123;</span><br><span class="line">   <span class="keyword">if</span> i.Path.Value == <span class="string">`&quot;fmt&quot;`</span> &#123;</span><br><span class="line">      hasFmtImport = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> hasFmtImport &amp;amp;&amp;amp; hasEcodingJsonImport &amp;amp;&amp;amp; hasRuntime &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if !onlyMain &amp;amp;&amp;amp; !hasFmtImport &#123;</span></span><br><span class="line"><span class="keyword">if</span> !hasFmtImport &#123;</span><br><span class="line">   pf.Imports = <span class="built_in">append</span>(pf.Imports, &amp;amp;ast.ImportSpec&#123;</span><br><span class="line">      Path: &amp;amp;ast.BasicLit&#123;</span><br><span class="line">         Value: <span class="string">`&quot;fmt&quot;`</span>,</span><br><span class="line">         Kind:  token.STRING,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(pf.Decls) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      d, ok := pf.Decls[<span class="number">0</span>].(*ast.GenDecl)</span><br><span class="line">      <span class="keyword">if</span> ok &#123;</span><br><span class="line">         d.Specs = <span class="built_in">append</span>(d.Specs, &amp;amp;ast.ImportSpec&#123;</span><br><span class="line">            Path: &amp;amp;ast.BasicLit&#123;</span><br><span class="line">               Kind:  token.STRING,</span><br><span class="line">               Value: <span class="string">`&quot;fmt&quot;`</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// case : no import</span></span><br><span class="line">         pf.Decls = <span class="built_in">append</span>([]ast.Decl&#123;</span><br><span class="line">            &amp;amp;ast.GenDecl&#123;</span><br><span class="line">               Specs: []ast.Spec&#123;</span><br><span class="line">                  &amp;amp;ast.ImportSpec&#123;</span><br><span class="line">                     Path: &amp;amp;ast.BasicLit&#123;</span><br><span class="line">                        Kind:  token.STRING,</span><br><span class="line">                        Value: <span class="string">`&quot;fmt&quot;`</span>,</span><br><span class="line">                     &#125;,</span><br><span class="line">                  &#125;,</span><br><span class="line">               &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">         &#125;, pf.Decls...)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pf.Decls = <span class="built_in">append</span>([]ast.Decl&#123;</span><br><span class="line">         &amp;amp;ast.GenDecl&#123;</span><br><span class="line">            Specs: []ast.Spec&#123;</span><br><span class="line">               &amp;amp;ast.ImportSpec&#123;</span><br><span class="line">                  Path: &amp;amp;ast.BasicLit&#123;</span><br><span class="line">                     Kind:  token.STRING,</span><br><span class="line">                     Value: <span class="string">`&quot;fmt&quot;`</span>,</span><br><span class="line">                  &#125;,</span><br><span class="line">               &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">         &#125;,</span><br><span class="line">      &#125;, pf.Decls...)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>重新编译golang，执行go run</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go clean -cache; go run helloworld/main.go</span><br><span class="line">start UGO...</span><br><span class="line">hello world</span><br><span class="line">end UGO...</span><br></pre></td></tr></table></figure>

<p>成功。</p>
<p>当然实际的业务场景对源码的定制远比上面这个例子复杂，他虽然没有像java的AspectJ方案那样的完整，但是与业务代码完全解耦和一键式录制的特点使这种方案能适应更多的场景，瓶颈可能就是定制版的go的开发比较繁琐，还有很大的优化空间。</p>
<p>文章技术参考：</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/</a><br><br/><br><a target="_blank" rel="noopener" href="https://blog.51cto.com/onebig/2510835">https://blog.51cto.com/onebig/2510835</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">也许拜了个拜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/01/从编译器角度出发探索如何在go中实现AOP/">http://example.com/2021/11/01/从编译器角度出发探索如何在go中实现AOP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">maybeByeのspace</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/11/01/%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96ifelse/"><span>表结构优化ifelse</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/img/banner.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By 也许拜了个拜</div><div class="framework-info"></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>